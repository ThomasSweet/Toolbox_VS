package de.sb.toolbox.math;

import java.util.concurrent.ThreadLocalRandom;
import java.util.function.DoubleSupplier;
import de.sb.toolbox.Copyright;


/**
 * This interface is implemented by suppliers of noise signals within range <tt>[-1,+1]</tt>. It's instances model colors of
 * noise, which differ in their respective power spectral density.
 * @see <a href="http://en.wikipedia.org/wiki/Colors_of_noise">Colors of Noise</a>
 */
@FunctionalInterface
@Copyright(year = 2008, holders = "Sascha Baumeister")
public interface NoiseSupplier extends DoubleSupplier {

	/**
	 * Returns the next noise value.
	 * @return a value within range <tt>[-1,+1]</tt>
	 */
	double getAsDouble ();


	/**
	 * Returns a new instance that supplies {@code violet noise} values within range <tt>[-1,+1[</tt>. Within violet noise the
	 * noise power {@code p(f)} is propertional to <tt>f<sup>+2</sup></tt>, which translates to a change (increase) of noise
	 * volume by {@code +6dB} per octave. It is generated by differentiating white noise.
	 * @return the violet noise supplier created
	 */
	static NoiseSupplier newVioletNoiseInstance () {
		return new NoiseSupplier() {
			private final NoiseSupplier whiteNoiseSupplier = newWhiteNoiseInstance();
			private volatile double feedback = 0;


			public double getAsDouble () {
				final double value = this.whiteNoiseSupplier.getAsDouble();
				final double result = (value - this.feedback) * .5d;
				this.feedback = value;
				return result;
			}
		};
	}


	/**
	 * Returns a new instance that supplies {@code blue noise} values within range <tt>[-1,+1[</tt>. Within blue noise the noise
	 * power {@code p(f)} is propertional to <tt>f<sup>+1</sup></tt>, which translates to a change (increase) of noise volume by
	 * {@code +3dB} per octave. It is generated by differentiating pink noise.
	 * @return the blue noise supplier created
	 */
	static NoiseSupplier newBlueNoiseInstance () {
		return new NoiseSupplier() {
			private final NoiseSupplier pinkNoiseSupplier = newPinkNoiseInstance();
			private volatile double feedback = 0;


			public double getAsDouble () {
				final double value = this.pinkNoiseSupplier.getAsDouble();
				final double result = (value - this.feedback) * .5d;
				this.feedback = value;
				return result;
			}
		};
	}


	/**
	 * Returns a new instance that supplies {@code white noise} values within range <tt>[-1,+1[</tt>. Within white noise the
	 * noise power{@code p(f)} is propertional to <tt>f<sup>0</sup></tt>, which translates to constant noise volume per octave.
	 * It is generated using a thread-local random number generator.
	 * @return the white noise supplier created
	 */
	static NoiseSupplier newWhiteNoiseInstance () {
		return () -> ThreadLocalRandom.current().nextDouble() * 2 - 1;
	}


	/**
	 * Returns a new instance that supplies {@code pink noise} values within range <tt>[-1,+1[</tt>. Within pink noise the noise
	 * power {@code p(f)} is propertional to <tt>f<sup>-1</sup></tt>, which translates to a change (decrease) of noise volume by
	 * {@code -3dB} per octave. It is generated using a 5 stage weighted stochastically correlated {@code Voss-McCartney}
	 * algorithm published by Larry Trammell in 2006. It generates pink noise distributed pretty evenly to about 0.0075 times
	 * the {@code Nyquist} frequency.
	 * @return the pink noise supplier created
	 */
	static NoiseSupplier newPinkNoiseInstance () {
		return new NoiseSupplier() {
			private final NoiseSupplier whiteNoiseSupplier = newWhiteNoiseInstance();
			private final double[] chances = new double[] { 0.84429, 0.69806, 0.25885, 0.06997, 0.01965 };
			private final double[] weights = new double[] { 0.06347, 0.23264, 0.22612, 0.19665, 0.28110 };;
			private final double[] values = new double[5];


			{
				this.updateValuesByChance(0);
			}


			private void updateValuesByChance (final double pivot) {
				for (int index = 0; index < this.values.length; ++index) {
					if (pivot < this.chances[index]) this.values[index] = this.weights[index] * this.whiteNoiseSupplier.getAsDouble();
				}
			}


			public double getAsDouble () {
				this.updateValuesByChance(ThreadLocalRandom.current().nextDouble());
				double sum = 0;
				for (int index = 0; index < this.values.length; ++index)
					sum += this.values[index];
				return sum;
			}
		};
	}


	/**
	 * Returns a new instance that supplies {@code red noise} (brownian) values within range <tt>[-1,+1[</tt>. Within red noise
	 * the noise power {@code p(f)} is propertional to <tt>f<sup>-2</sup></tt>, which translates to a change (decrease) of noise
	 * volume by {@code -6dB} per octave. It is generated by integrating white noise. A differential approach is taken to make
	 * sure the integral values don't aquire an infrasound frequency component.
	 */
	static NoiseSupplier newRedNoiseInstance () {
		return new NoiseSupplier() {
			private final NoiseSupplier whiteNoiseSupplier = newWhiteNoiseInstance();
			private final double[] values = new double[1 << 9];
			private volatile double sum = 0;
			private volatile int readPosition = 0;


			public double getAsDouble () {
				if (this.readPosition == this.values.length) this.readPosition = 0;
				final double value = this.values[this.readPosition];
				this.values[this.readPosition] = this.whiteNoiseSupplier.getAsDouble();
				this.sum += this.values[this.readPosition++] - value;
				return this.sum / (this.values.length >> 3);
			}
		};
	}
}